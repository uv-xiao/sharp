//===- ArcilatorIntegrationPass.cpp - Arcilator Integration Pass ----------===//
//
// This file implements integration with CIRCT's arcilator for RTL simulation.
//
//===----------------------------------------------------------------------===//

#include "sharp/Simulation/Passes.h"
#include "sharp/Dialect/Txn/TxnOps.h"
#include "sharp/Conversion/Passes.h"
#include "circt/Dialect/Arc/ArcDialect.h"
#include "circt/Dialect/Arc/ArcOps.h"
#include "circt/Dialect/Arc/ArcPasses.h"
#include "circt/Dialect/HW/HWDialect.h"
#include "circt/Dialect/HW/HWOps.h"
#include "circt/Dialect/Seq/SeqOps.h"
#include "circt/Dialect/Comb/CombOps.h"
#include "circt/Dialect/Emit/EmitDialect.h"
#include "circt/Dialect/SV/SVDialect.h"
#include "circt/Dialect/FIRRTL/FIRRTLDialect.h"
#include "circt/Dialect/Sim/SimDialect.h"
#include "circt/Dialect/Verif/VerifDialect.h"
#include "circt/Support/LLVM.h"
#include "circt/Conversion/Passes.h"
#include "circt/Conversion/ConvertToArcs.h"
#include "circt/Conversion/ArcToLLVM.h"
#include "circt/Conversion/FIRRTLToHW.h"
#include "mlir/Dialect/Arith/IR/Arith.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/SCF/IR/SCF.h"
#include "mlir/Dialect/UB/IR/UBOps.h"
#include "mlir/IR/BuiltinOps.h"
#include "mlir/Pass/Pass.h"
#include "mlir/Pass/PassManager.h"
#include "mlir/Transforms/Passes.h"
#include "mlir/Conversion/FuncToLLVM/ConvertFuncToLLVMPass.h"
#include "mlir/Conversion/ReconcileUnrealizedCasts/ReconcileUnrealizedCasts.h"
#include "llvm/Support/raw_ostream.h"

namespace sharp {

#define GEN_PASS_DEF_ARCILATORINTEGRATIONPASS  
#include "sharp/Simulation/Passes.h.inc"

namespace {

/// The arcilator integration pass
struct ArcilatorIntegrationPass : public impl::ArcilatorIntegrationPassBase<ArcilatorIntegrationPass> {
  using Base = impl::ArcilatorIntegrationPassBase<ArcilatorIntegrationPass>;
  
  // Constructor needed for TableGen
  ArcilatorIntegrationPass() = default;
  ArcilatorIntegrationPass(const ArcilatorIntegrationPassOptions& options) {
    enableTracing = options.enableTracing;
    traceFile = options.traceFile;
  }

  void runOnOperation() override {
    auto module = getOperation();
    
    // Step 1: Convert Txn to FIRRTL to HW
    mlir::PassManager conversionPM(&getContext());
    conversionPM.enableVerifier(true);
    
    // Add Txn to FIRRTL conversion
    conversionPM.addPass(mlir::sharp::createTxnToFIRRTLConversion());
    
    // Add FIRRTL to HW lowering (with default options)
    conversionPM.addPass(circt::createLowerFIRRTLToHWPass(
        /*enableAnnotationWarning=*/false,
        /*assertionFlavor=*/circt::firrtl::VerificationFlavor::None));
    
    // Add any necessary canonicalizations
    conversionPM.addPass(mlir::createCanonicalizerPass());
    
    if (failed(conversionPM.run(module))) {
      module.emitError() << "Failed to convert Txn to HW dialect";
      signalPassFailure();
      return;
    }
    
    // Step 2: Convert HW to Arc dialect for simulation
    mlir::PassManager arcPM(&getContext());
    arcPM.enableVerifier(true);
    
    // Add the HW to Arc conversion (with default options)
    arcPM.addPass(circt::createConvertToArcsPass({}));
    arcPM.addPass(circt::arc::createArcCanonicalizerPass());
    arcPM.addPass(mlir::createCanonicalizerPass());
    
    if (failed(arcPM.run(module))) {
      module.emitError() << "Failed to convert HW to Arc dialect";
      signalPassFailure();
      return;
    }
    
    // Step 3: Report successful conversion
    module.emitRemark() << "Successfully converted to Arc dialect for RTL simulation";
    
    // The converted module can now be:
    // 1. Further lowered to LLVM for JIT execution via arcilator
    // 2. Used with CIRCT's arcilator tool for simulation
    // 3. Exported to SystemVerilog for co-simulation
    
    if (enableTracing) {
      module.emitRemark() << "VCD tracing would be enabled for file: " << traceFile;
      module.emitRemark() << "Use 'arcilator' tool with --trace option to generate VCD";
    }
    
    // Emit instructions for running with arcilator
    module.emitRemark() << "To simulate this module:";
    module.emitRemark() << "  arcilator <output.mlir> --run --jit-entry=main";
    module.emitRemark() << "Or with VCD tracing:";
    module.emitRemark() << "  arcilator <output.mlir> --run --jit-entry=main --trace";
  }
};

} // namespace

// Note: The createArcilatorIntegrationPass function is generated by TableGen

} // namespace sharp