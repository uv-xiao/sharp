//===- TXNOps.cpp - TXN dialect operations implementation -----------------===//
//
// Part of the Sharp Project.
//
//===----------------------------------------------------------------------===//

#include "sharp/Dialect/TXN/TXNOps.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/OpImplementation.h"
#include "mlir/Interfaces/FunctionImplementation.h"

using namespace mlir;
using namespace sharp;
using namespace sharp::txn;

//===----------------------------------------------------------------------===//
// ModuleOp
//===----------------------------------------------------------------------===//

// Build method is generated by TableGen

ParseResult ModuleOp::parse(OpAsmParser &parser, OperationState &result) {
  StringAttr nameAttr;
  if (parser.parseSymbolName(nameAttr, mlir::SymbolTable::getSymbolAttrName(),
                            result.attributes))
    return failure();

  // Parse the body region.
  Region *body = result.addRegion();
  if (parser.parseRegion(*body, /*arguments=*/{}, /*argTypes=*/{}))
    return failure();

  // Ensure the body has at least one block.
  if (body->empty())
    body->emplaceBlock();

  return success();
}

void ModuleOp::print(OpAsmPrinter &p) {
  p << " @" << getSymName();
  p << " ";
  p.printRegion(getBody(), /*printEntryBlockArgs=*/false,
                /*printBlockTerminators=*/true);
}

LogicalResult ModuleOp::verify() {
  // Ensure the module has a body block.
  if (getBody().empty())
    return emitOpError("expected a body block");
  
  // Ensure the module ends with a schedule.
  Block &bodyBlock = getBody().front();
  if (bodyBlock.empty())
    return emitOpError("module body cannot be empty");
    
  auto *terminator = bodyBlock.getTerminator();
  if (!isa<ScheduleOp>(terminator))
    return emitOpError("module must end with a 'txn.schedule' operation");
  
  return success();
}

//===----------------------------------------------------------------------===//
// PrimitiveOp
//===----------------------------------------------------------------------===//

// Build method is generated by TableGen

ParseResult PrimitiveOp::parse(OpAsmParser &parser, OperationState &result) {
  StringAttr nameAttr;
  StringAttr typeAttr;
  TypeAttr interfaceTypeAttr;
  
  // Parse symbol name
  if (parser.parseSymbolName(nameAttr, mlir::SymbolTable::getSymbolAttrName(),
                            result.attributes))
    return failure();
    
  // Parse 'type = "hw"' or 'type = "spec"'
  if (parser.parseKeyword("type") || parser.parseEqual())
    return failure();
    
  std::string typeStr;
  if (parser.parseString(&typeStr))
    return failure();
    
  typeAttr = parser.getBuilder().getStringAttr(typeStr);
  result.addAttribute("type", typeAttr);
  
  // Parse 'interface = !txn.module<"...">'
  if (parser.parseKeyword("interface") || parser.parseEqual())
    return failure();
    
  Type interfaceType;
  if (parser.parseType(interfaceType))
    return failure();
    
  interfaceTypeAttr = TypeAttr::get(interfaceType);
  result.addAttribute("interface_type", interfaceTypeAttr);
  
  // Parse the body region
  Region *body = result.addRegion();
  if (parser.parseRegion(*body, /*arguments=*/{}, /*argTypes=*/{}))
    return failure();
  
  // Ensure the body has at least one block
  if (body->empty())
    body->emplaceBlock();
    
  if (parser.parseOptionalAttrDict(result.attributes))
    return failure();
    
  return success();
}

void PrimitiveOp::print(OpAsmPrinter &p) {
  p << " @" << getSymName();
  p << " type = \"" << getType() << "\"";
  p << " interface = ";
  p.printType(getInterfaceType());
  p << " ";
  p.printRegion(getBody(), /*printEntryBlockArgs=*/false,
                /*printBlockTerminators=*/true);
  p.printOptionalAttrDict((*this)->getAttrs(), 
                         {mlir::SymbolTable::getSymbolAttrName(), "type", "interface_type"});
}

LogicalResult PrimitiveOp::verify() {
  // Verify type is either "hw" or "spec".
  auto type = getType();
  if (type != "hw" && type != "spec")
    return emitOpError("type must be either 'hw' or 'spec'");
  
  return success();
}

//===----------------------------------------------------------------------===//
// ValueMethodOp
//===----------------------------------------------------------------------===//

// Build method is generated by TableGen

ParseResult ValueMethodOp::parse(OpAsmParser &parser, OperationState &result) {
  auto buildFuncType =
      [](Builder &builder, ArrayRef<Type> argTypes, ArrayRef<Type> results,
         function_interface_impl::VariadicFlag,
         std::string &) { return builder.getFunctionType(argTypes, results); };

  return function_interface_impl::parseFunctionOp(
      parser, result, /*allowVariadic=*/false,
      getFunctionTypeAttrName(result.name), buildFuncType,
      getArgAttrsAttrName(result.name), getResAttrsAttrName(result.name));
}

void ValueMethodOp::print(OpAsmPrinter &p) {
  function_interface_impl::printFunctionOp(
      p, *this, /*isVariadic=*/false, getFunctionTypeAttrName(),
      getArgAttrsAttrName(), getResAttrsAttrName());
}

//===----------------------------------------------------------------------===//
// ActionMethodOp
//===----------------------------------------------------------------------===//

// Build method is generated by TableGen

ParseResult ActionMethodOp::parse(OpAsmParser &parser, OperationState &result) {
  auto buildFuncType =
      [](Builder &builder, ArrayRef<Type> argTypes, ArrayRef<Type> results,
         function_interface_impl::VariadicFlag,
         std::string &) { return builder.getFunctionType(argTypes, results); };

  return function_interface_impl::parseFunctionOp(
      parser, result, /*allowVariadic=*/false,
      getFunctionTypeAttrName(result.name), buildFuncType,
      getArgAttrsAttrName(result.name), getResAttrsAttrName(result.name));
}

void ActionMethodOp::print(OpAsmPrinter &p) {
  function_interface_impl::printFunctionOp(
      p, *this, /*isVariadic=*/false, getFunctionTypeAttrName(),
      getArgAttrsAttrName(), getResAttrsAttrName());
}

//===----------------------------------------------------------------------===//
// RuleOp
//===----------------------------------------------------------------------===//

// Build method is generated by TableGen

ParseResult RuleOp::parse(OpAsmParser &parser, OperationState &result) {
  StringAttr nameAttr;
  if (parser.parseSymbolName(nameAttr, mlir::SymbolTable::getSymbolAttrName(),
                            result.attributes))
    return failure();

  // Parse the body region.
  Region *body = result.addRegion();
  if (parser.parseRegion(*body, /*arguments=*/{}, /*argTypes=*/{}))
    return failure();

  // Ensure the body has at least one block.
  if (body->empty())
    body->emplaceBlock();
    
  if (parser.parseOptionalAttrDict(result.attributes))
    return failure();

  return success();
}

void RuleOp::print(OpAsmPrinter &p) {
  p << " @" << getSymName();
  p << " ";
  p.printRegion(getBody(), /*printEntryBlockArgs=*/false,
                /*printBlockTerminators=*/true);
  p.printOptionalAttrDict((*this)->getAttrs(), 
                         {mlir::SymbolTable::getSymbolAttrName()});
}

//===----------------------------------------------------------------------===//
// ScheduleOp
//===----------------------------------------------------------------------===//

// Build method is generated by TableGen

// ScheduleOp now uses assemblyFormat, so no custom parser/printer needed

//===----------------------------------------------------------------------===//
// IfOp
//===----------------------------------------------------------------------===//

// Build method is generated by TableGen

ParseResult IfOp::parse(OpAsmParser &parser, OperationState &result) {
  OpAsmParser::UnresolvedOperand cond;
  Type condType = parser.getBuilder().getI1Type();
  
  if (parser.parseOperand(cond) ||
      parser.resolveOperand(cond, condType, result.operands))
    return failure();

  // Parse optional result types.
  SmallVector<Type> resultTypes;
  if (succeeded(parser.parseOptionalArrowTypeList(resultTypes)))
    result.addTypes(resultTypes);

  // Parse then region.
  Region *thenRegion = result.addRegion();
  if (parser.parseRegion(*thenRegion, /*arguments=*/{}, /*argTypes=*/{}))
    return failure();

  // Parse else keyword and region.
  if (parser.parseKeyword("else"))
    return failure();
  
  Region *elseRegion = result.addRegion();
  if (parser.parseRegion(*elseRegion, /*arguments=*/{}, /*argTypes=*/{}))
    return failure();

  return success();
}

void IfOp::print(OpAsmPrinter &p) {
  p << " " << getCondition();
  if (!getResults().empty()) {
    p.printArrowTypeList(getResultTypes());
  }
  p << " ";
  p.printRegion(getThenRegion());
  p << " else ";
  p.printRegion(getElseRegion());
}

LogicalResult IfOp::verify() {
  // TODO: Verify that both regions yield compatible types.
  return success();
}

void IfOp::getRegionInvocationBounds(
    ArrayRef<Attribute> operands,
    SmallVectorImpl<InvocationBounds> &invocationBounds) {
  // Then region is always executed at most once.
  invocationBounds.push_back({0, 1});
  // Else region (if present) is also executed at most once.
  if (!getElseRegion().empty())
    invocationBounds.push_back({0, 1});
}

void IfOp::getSuccessorRegions(RegionBranchPoint point,
                                SmallVectorImpl<RegionSuccessor> &successors) {
  // If branching from the parent, we can enter either the then or else region.
  if (point.isParent()) {
    successors.push_back(RegionSuccessor(&getThenRegion()));
    successors.push_back(RegionSuccessor(&getElseRegion()));
    return;
  }

  // If coming from either region, we branch back to the parent.
  if (point.getRegionOrNull() == &getThenRegion() ||
      point.getRegionOrNull() == &getElseRegion()) {
    successors.push_back(RegionSuccessor(getResults()));
  }
}

void IfOp::getEntrySuccessorRegions(
    ArrayRef<Attribute> operands,
    SmallVectorImpl<RegionSuccessor> &successors) {
  // The condition can branch to either the then or else region.
  successors.push_back(RegionSuccessor(&getThenRegion()));
  if (!getElseRegion().empty())
    successors.push_back(RegionSuccessor(&getElseRegion()));
  else
    successors.push_back(RegionSuccessor(getResults()));
}

//===----------------------------------------------------------------------===//
// CallOp
//===----------------------------------------------------------------------===//

// Build method is generated by TableGen

ParseResult CallOp::parse(OpAsmParser &parser, OperationState &result) {
  SymbolRefAttr calleeAttr;
  SmallVector<OpAsmParser::UnresolvedOperand, 4> operands;
  SmallVector<Type> operandTypes;
  SmallVector<Type> resultTypes;

  // Parse @callee or @instance.method
  if (parser.parseAttribute(calleeAttr, "callee", result.attributes))
    return failure();

  // Parse (operands)
  if (parser.parseOperandList(operands, OpAsmParser::Delimiter::Paren))
    return failure();

  // Parse : (operand_types) -> result_types
  if (parser.parseColon())
    return failure();

  // Parse function type
  FunctionType funcType;
  if (parser.parseType(funcType))
    return failure();

  operandTypes = llvm::to_vector(funcType.getInputs());
  resultTypes = llvm::to_vector(funcType.getResults());

  result.addTypes(resultTypes);

  return parser.resolveOperands(operands, operandTypes, parser.getNameLoc(),
                               result.operands);
}

void CallOp::print(OpAsmPrinter &p) {
  p << " ";
  p.printAttributeWithoutType(getCalleeAttr());
  p << "(";
  p.printOperands(getOperands());
  p << ") : ";
  
  // Print as function type
  auto funcType = FunctionType::get(getContext(), getOperandTypes(), getResultTypes());
  p.printType(funcType);
}

LogicalResult CallOp::verify() {
  // TODO: Verify that the callee exists and has matching signature.
  return success();
}


//===----------------------------------------------------------------------===//
// Operation definitions
//===----------------------------------------------------------------------===//

#define GET_OP_CLASSES
#include "sharp/Dialect/TXN/TXN.cpp.inc"