//===- TxnOps.cpp - Txn dialect operations implementation -----------------===//
//
// Part of the Sharp Project.
//
//===----------------------------------------------------------------------===//

#include "sharp/Dialect/Txn/TxnOps.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/OpImplementation.h"
#include "mlir/Interfaces/FunctionImplementation.h"

using namespace mlir;
using namespace sharp;
using namespace sharp::txn;

//===----------------------------------------------------------------------===//
// ModuleOp
//===----------------------------------------------------------------------===//

// Assembly format is now generated by TableGen

LogicalResult ModuleOp::verify() {
  // Ensure the module has a body block.
  if (getBody().empty())
    return emitOpError("expected a body block");
  
  // Ensure the module ends with a schedule.
  Block &bodyBlock = getBody().front();
  if (bodyBlock.empty())
    return emitOpError("module body cannot be empty");
    
  // Since ModuleOp has NoTerminator trait, check if the last operation is a ScheduleOp
  auto *lastOp = &bodyBlock.back();
  if (!isa<ScheduleOp>(lastOp))
    return emitOpError("module must end with a 'txn.schedule' operation");
  
  return success();
}

//===----------------------------------------------------------------------===//
// PrimitiveOp
//===----------------------------------------------------------------------===//

// Build method is generated by TableGen

ParseResult PrimitiveOp::parse(OpAsmParser &parser, OperationState &result) {
  StringAttr nameAttr;
  StringAttr typeAttr;
  TypeAttr interfaceTypeAttr;
  SmallVector<Attribute> typeParams;
  
  // Parse symbol name
  if (parser.parseSymbolName(nameAttr, mlir::SymbolTable::getSymbolAttrName(),
                            result.attributes))
    return failure();
    
  // Parse optional type parameters: <T1, T2, ...>
  if (succeeded(parser.parseOptionalLess())) {
    do {
      StringRef paramName;
      if (parser.parseKeyword(&paramName))
        return failure();
      typeParams.push_back(parser.getBuilder().getStringAttr(paramName));
    } while (succeeded(parser.parseOptionalComma()));
    
    if (parser.parseGreater())
      return failure();
      
    result.addAttribute("type_parameters", 
                       parser.getBuilder().getArrayAttr(typeParams));
  }
    
  // Parse 'type = "hw"' or 'type = "spec"'
  if (parser.parseKeyword("type") || parser.parseEqual())
    return failure();
    
  std::string typeStr;
  if (parser.parseString(&typeStr))
    return failure();
    
  typeAttr = parser.getBuilder().getStringAttr(typeStr);
  result.addAttribute("type", typeAttr);
  
  // Parse 'interface = !txn.module<"...">'
  if (parser.parseKeyword("interface") || parser.parseEqual())
    return failure();
    
  Type interfaceType;
  if (parser.parseType(interfaceType))
    return failure();
    
  interfaceTypeAttr = TypeAttr::get(interfaceType);
  result.addAttribute("interface_type", interfaceTypeAttr);
  
  // Parse the body region
  Region *body = result.addRegion();
  if (parser.parseRegion(*body, /*arguments=*/{}, /*argTypes=*/{}))
    return failure();
  
  // Ensure the body has at least one block
  if (body->empty())
    body->emplaceBlock();
    
  if (parser.parseOptionalAttrDict(result.attributes))
    return failure();
    
  return success();
}

void PrimitiveOp::print(OpAsmPrinter &p) {
  p << " @" << getSymName();
  
  // Print type parameters if present
  if (auto typeParamsOpt = getTypeParameters()) {
    auto typeParams = typeParamsOpt.value();
    p << "<";
    llvm::interleaveComma(typeParams, p, [&](Attribute attr) {
      if (auto strAttr = dyn_cast<StringAttr>(attr))
        p << strAttr.getValue();
    });
    p << ">";
  }
  
  p << " type = \"" << getType() << "\"";
  p << " interface = ";
  p.printType(getInterfaceType());
  p << " ";
  p.printRegion(getBody(), /*printEntryBlockArgs=*/false,
                /*printBlockTerminators=*/true);
  p.printOptionalAttrDict((*this)->getAttrs(), 
                         {mlir::SymbolTable::getSymbolAttrName(), "type", 
                          "interface_type", "type_parameters"});
}

LogicalResult PrimitiveOp::verify() {
  // Verify type is either "hw" or "spec".
  auto type = getType();
  if (type != "hw" && type != "spec")
    return emitOpError("type must be either 'hw' or 'spec'");
  
  return success();
}

//===----------------------------------------------------------------------===//
// InstanceOp
//===----------------------------------------------------------------------===//

ParseResult InstanceOp::parse(OpAsmParser &parser, OperationState &result) {
  StringAttr nameAttr;
  FlatSymbolRefAttr moduleRef;
  SmallVector<Attribute> typeArgs;
  Type resultType;

  // Parse: @instance_name
  if (parser.parseSymbolName(nameAttr, mlir::SymbolTable::getSymbolAttrName(),
                            result.attributes))
    return failure();

  // Parse: of
  if (parser.parseKeyword("of"))
    return failure();

  // Parse: @ModuleName
  if (parser.parseAttribute(moduleRef, "module_name", result.attributes))
    return failure();

  // Parse optional type arguments: <type1, type2, ...>
  if (succeeded(parser.parseOptionalLess())) {
    do {
      TypeAttr typeAttr;
      Type type;
      if (parser.parseType(type))
        return failure();
      typeAttr = TypeAttr::get(type);
      typeArgs.push_back(typeAttr);
    } while (succeeded(parser.parseOptionalComma()));
    
    if (parser.parseGreater())
      return failure();
      
    result.attributes.push_back(parser.getBuilder().getNamedAttr(
        "type_arguments", parser.getBuilder().getArrayAttr(typeArgs)));
  }

  // Parse optional attributes
  if (parser.parseOptionalAttrDict(result.attributes))
    return failure();

  // Parse: : type
  if (parser.parseColon() || parser.parseType(resultType))
    return failure();

  result.addTypes(resultType);
  return success();
}

void InstanceOp::print(OpAsmPrinter &p) {
  p << " @" << getSymName() << " of ";
  p.printAttribute(getModuleNameAttr());
  
  // Print type arguments if present
  if (auto typeArgsOpt = getTypeArguments()) {
    auto typeArgs = typeArgsOpt.value();
    p << "<";
    llvm::interleaveComma(typeArgs, p, [&](Attribute attr) {
      if (auto typeAttr = dyn_cast<TypeAttr>(attr))
        p.printType(typeAttr.getValue());
    });
    p << ">";
  }
  
  p.printOptionalAttrDict((*this)->getAttrs(), 
                         {mlir::SymbolTable::getSymbolAttrName(), 
                          "module_name", "type_arguments"});
  p << " : ";
  p.printType(getType());
}

LogicalResult InstanceOp::verify() {
  // TODO: Add verification for type arguments matching primitive parameters
  return success();
}

//===----------------------------------------------------------------------===//
// ValueMethodOp
//===----------------------------------------------------------------------===//

// Build method is generated by TableGen

ParseResult ValueMethodOp::parse(OpAsmParser &parser, OperationState &result) {
  auto buildFuncType =
      [](Builder &builder, ArrayRef<Type> argTypes, ArrayRef<Type> results,
         function_interface_impl::VariadicFlag,
         std::string &) { return builder.getFunctionType(argTypes, results); };

  return function_interface_impl::parseFunctionOp(
      parser, result, /*allowVariadic=*/false,
      getFunctionTypeAttrName(result.name), buildFuncType,
      getArgAttrsAttrName(result.name), getResAttrsAttrName(result.name));
}

void ValueMethodOp::print(OpAsmPrinter &p) {
  function_interface_impl::printFunctionOp(
      p, *this, /*isVariadic=*/false, getFunctionTypeAttrName(),
      getArgAttrsAttrName(), getResAttrsAttrName());
}

//===----------------------------------------------------------------------===//
// ActionMethodOp
//===----------------------------------------------------------------------===//

// Build method is generated by TableGen

ParseResult ActionMethodOp::parse(OpAsmParser &parser, OperationState &result) {
  auto buildFuncType =
      [](Builder &builder, ArrayRef<Type> argTypes, ArrayRef<Type> results,
         function_interface_impl::VariadicFlag,
         std::string &) { return builder.getFunctionType(argTypes, results); };

  return function_interface_impl::parseFunctionOp(
      parser, result, /*allowVariadic=*/false,
      getFunctionTypeAttrName(result.name), buildFuncType,
      getArgAttrsAttrName(result.name), getResAttrsAttrName(result.name));
}

void ActionMethodOp::print(OpAsmPrinter &p) {
  function_interface_impl::printFunctionOp(
      p, *this, /*isVariadic=*/false, getFunctionTypeAttrName(),
      getArgAttrsAttrName(), getResAttrsAttrName());
}

//===----------------------------------------------------------------------===//
// RuleOp
//===----------------------------------------------------------------------===//

// Build method is generated by TableGen

ParseResult RuleOp::parse(OpAsmParser &parser, OperationState &result) {
  StringAttr nameAttr;
  if (parser.parseSymbolName(nameAttr, mlir::SymbolTable::getSymbolAttrName(),
                            result.attributes))
    return failure();

  // Parse the body region.
  Region *body = result.addRegion();
  if (parser.parseRegion(*body, /*arguments=*/{}, /*argTypes=*/{}))
    return failure();

  // Ensure the body has at least one block.
  if (body->empty())
    body->emplaceBlock();
    
  if (parser.parseOptionalAttrDict(result.attributes))
    return failure();

  return success();
}

void RuleOp::print(OpAsmPrinter &p) {
  p << " @" << getSymName();
  p << " ";
  p.printRegion(getBody(), /*printEntryBlockArgs=*/false,
                /*printBlockTerminators=*/true);
  p.printOptionalAttrDict((*this)->getAttrs(), 
                         {mlir::SymbolTable::getSymbolAttrName()});
}

//===----------------------------------------------------------------------===//
// ScheduleOp
//===----------------------------------------------------------------------===//

// Build method is generated by TableGen

// ScheduleOp now uses assemblyFormat, so no custom parser/printer needed

//===----------------------------------------------------------------------===//
// IfOp
//===----------------------------------------------------------------------===//

// Build method is generated by TableGen

ParseResult IfOp::parse(OpAsmParser &parser, OperationState &result) {
  OpAsmParser::UnresolvedOperand cond;
  Type condType = parser.getBuilder().getI1Type();
  
  if (parser.parseOperand(cond) ||
      parser.resolveOperand(cond, condType, result.operands))
    return failure();

  // Parse optional result types.
  SmallVector<Type> resultTypes;
  if (succeeded(parser.parseOptionalArrowTypeList(resultTypes)))
    result.addTypes(resultTypes);

  // Parse then region.
  Region *thenRegion = result.addRegion();
  if (parser.parseRegion(*thenRegion, /*arguments=*/{}, /*argTypes=*/{}))
    return failure();

  // Parse else keyword and region.
  if (parser.parseKeyword("else"))
    return failure();
  
  Region *elseRegion = result.addRegion();
  if (parser.parseRegion(*elseRegion, /*arguments=*/{}, /*argTypes=*/{}))
    return failure();

  return success();
}

void IfOp::print(OpAsmPrinter &p) {
  p << " " << getCondition();
  if (!getResults().empty()) {
    p.printArrowTypeList(getResultTypes());
  }
  p << " ";
  p.printRegion(getThenRegion());
  p << " else ";
  p.printRegion(getElseRegion());
}

LogicalResult IfOp::verify() {
  // TODO: Verify that both regions yield compatible types.
  return success();
}

void IfOp::getRegionInvocationBounds(
    ArrayRef<Attribute> operands,
    SmallVectorImpl<InvocationBounds> &invocationBounds) {
  // Then region is always executed at most once.
  invocationBounds.push_back({0, 1});
  // Else region (if present) is also executed at most once.
  if (!getElseRegion().empty())
    invocationBounds.push_back({0, 1});
}

void IfOp::getSuccessorRegions(RegionBranchPoint point,
                                SmallVectorImpl<RegionSuccessor> &successors) {
  // If branching from the parent, we can enter either the then or else region.
  if (point.isParent()) {
    successors.push_back(RegionSuccessor(&getThenRegion()));
    successors.push_back(RegionSuccessor(&getElseRegion()));
    return;
  }

  // If coming from either region, we branch back to the parent.
  if (point.getRegionOrNull() == &getThenRegion() ||
      point.getRegionOrNull() == &getElseRegion()) {
    successors.push_back(RegionSuccessor(getResults()));
  }
}

void IfOp::getEntrySuccessorRegions(
    ArrayRef<Attribute> operands,
    SmallVectorImpl<RegionSuccessor> &successors) {
  // The condition can branch to either the then or else region.
  successors.push_back(RegionSuccessor(&getThenRegion()));
  if (!getElseRegion().empty())
    successors.push_back(RegionSuccessor(&getElseRegion()));
  else
    successors.push_back(RegionSuccessor(getResults()));
}

//===----------------------------------------------------------------------===//
// CallOp
//===----------------------------------------------------------------------===//

// Build method is generated by TableGen

ParseResult CallOp::parse(OpAsmParser &parser, OperationState &result) {
  SymbolRefAttr calleeAttr;
  SmallVector<OpAsmParser::UnresolvedOperand, 4> operands;
  SmallVector<Type> operandTypes;
  SmallVector<Type> resultTypes;
  OpAsmParser::UnresolvedOperand conditionOperand;
  Type conditionType;
  bool hasCondition = false;

  // Parse @callee or @instance.method
  if (parser.parseAttribute(calleeAttr, "callee", result.attributes))
    return failure();

  // Check for optional condition operand: if <cond> : <type> then (operands)
  if (succeeded(parser.parseOptionalKeyword("if"))) {
    hasCondition = true;
    if (parser.parseOperand(conditionOperand))
      return failure();
    if (parser.parseColon())
      return failure();
    if (parser.parseType(conditionType))
      return failure();
    if (parser.parseKeyword("then"))
      return failure();
  }

  // Parse (operands)
  if (parser.parseOperandList(operands, OpAsmParser::Delimiter::Paren))
    return failure();

  // Parse : (operand_types) -> result_types
  if (parser.parseColon())
    return failure();

  // Parse function type
  FunctionType funcType;
  if (parser.parseType(funcType))
    return failure();

  operandTypes = llvm::to_vector(funcType.getInputs());
  resultTypes = llvm::to_vector(funcType.getResults());

  result.addTypes(resultTypes);

  // Parse optional attributes
  if (parser.parseOptionalAttrDict(result.attributes))
    return failure();

  // Resolve operands
  SmallVector<OpAsmParser::UnresolvedOperand> allOperands;
  SmallVector<Type> allOperandTypes;
  
  if (hasCondition) {
    allOperands.push_back(conditionOperand);
    allOperandTypes.push_back(conditionType);
  }
  
  allOperands.append(operands.begin(), operands.end());
  allOperandTypes.append(operandTypes.begin(), operandTypes.end());

  // Set operandSegmentSizes attribute for AttrSizedOperandSegments trait
  SmallVector<int32_t, 2> segmentSizes;
  segmentSizes.push_back(hasCondition ? 1 : 0);  // condition
  segmentSizes.push_back(operands.size());        // args
  result.addAttribute("operandSegmentSizes",
                      parser.getBuilder().getDenseI32ArrayAttr(segmentSizes));

  return parser.resolveOperands(allOperands, allOperandTypes, parser.getNameLoc(),
                               result.operands);
}

void CallOp::print(OpAsmPrinter &p) {
  p << " ";
  p.printAttributeWithoutType(getCalleeAttr());
  
  // Check if we have a condition operand
  if (getCondition()) {
    p << " if ";
    p.printOperand(getCondition());
    p << " : ";
    p.printType(getCondition().getType());
    p << " then";
  }
  
  p << "(";
  p.printOperands(getArgs());
  p << ") : ";
  
  // Print as function type
  auto funcType = FunctionType::get(getContext(), getOperandTypes(), getResultTypes());
  p.printType(funcType);
  
  // Print attributes (excluding callee and operandSegmentSizes)
  SmallVector<StringRef> elidedAttrs = {"callee", "operandSegmentSizes"};
  p.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

LogicalResult CallOp::verify() {
  // TODO: Verify that the callee exists and has matching signature.
  return success();
}

//===----------------------------------------------------------------------===//
// LaunchOp
//===----------------------------------------------------------------------===//

LogicalResult LaunchOp::verify() {
  // Verify that the body has a terminator
  if (getBody().empty())
    return emitOpError("body region cannot be empty");
    
  // Check that the body is terminated properly
  Operation *terminator = getBody().back().getTerminator();
  if (!terminator || !isa<YieldOp>(terminator))
    return emitOpError("body must be terminated with 'txn.yield'");
  
  // If both condition and latency are provided, this is valid
  // If only condition is provided, this is a dynamic launch
  // If only latency is provided, this is a static launch
  // If neither is provided, it's an error
  if (!getCondition() && !getLatency())
    return emitOpError("launch must have either a condition or latency");
  
  return success();
}


//===----------------------------------------------------------------------===//
// FuncOp
//===----------------------------------------------------------------------===//

ParseResult FuncOp::parse(OpAsmParser &parser, OperationState &result) {
  auto buildFuncType =
      [](Builder &builder, ArrayRef<Type> argTypes, ArrayRef<Type> results,
         function_interface_impl::VariadicFlag,
         std::string &) { return builder.getFunctionType(argTypes, results); };

  return function_interface_impl::parseFunctionOp(
      parser, result, /*allowVariadic=*/false,
      getFunctionTypeAttrName(result.name), buildFuncType,
      getArgAttrsAttrName(result.name), getResAttrsAttrName(result.name));
}

void FuncOp::print(OpAsmPrinter &p) {
  function_interface_impl::printFunctionOp(
      p, *this, /*isVariadic=*/false, getFunctionTypeAttrName(),
      getArgAttrsAttrName(), getResAttrsAttrName());
}

// CallableOpInterface implementation
Region *FuncOp::getCallableRegion() { return &getBody(); }

ArrayRef<Type> FuncOp::getCallableResults() {
  return getFunctionType().getResults();
}

//===----------------------------------------------------------------------===//
// Operation definitions
//===----------------------------------------------------------------------===//

#define GET_OP_CLASSES
#include "sharp/Dialect/Txn/Txn.cpp.inc"